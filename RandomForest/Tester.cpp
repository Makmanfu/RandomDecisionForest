#include <iostream>
#include <string>
#include <sys/timeb.h>
#include <cv.h>
#include <cxcore.h>
#include <highgui.h>
#include <iomanip>
#include "RandomForest.h"
#include "DepthUtilities.h"
#include "TemplateParser.h"
using namespace std;

void ReadOneFrame(std::string strDir, int nIndex, cv::Mat &mtxDepthPoints,
	int** &pLabels, int &nWidth, int &nHeight, HandParams &param)
{
	LoadImages(strDir, nIndex, mtxDepthPoints, pLabels, nWidth, nHeight, param);
	cv::Mat mtxLabelColor(cv::Size(nWidth, nHeight), CV_8UC3);
	static cv::Mat mtxDepthVis = cv::Mat(cv::Size(nWidth, nHeight), CV_8UC3);
	const double MIN_DEPTH = 0.4;
	const double MAX_DEPTH = 1.0;
	for (int i = 0; i < mtxDepthPoints.rows; i++)
	{
		for (int j = 0; j < mtxDepthPoints.cols; j++)
		{
			pLabels[i][j] = MapToSampleLabel(pLabels[i][j]);
			if (mtxDepthPoints.at<cv::Vec3f>(i, j)[2] == 0.0)
			{
				mtxDepthPoints.at<cv::Vec3f>(i, j)[2] = g_fPlaneDepth;
				mtxDepthVis.at<cv::Vec3b>(i, j) = cv::Vec3b(0, 0, 0);
			}
			else
			{
				double fGray = (mtxDepthPoints.at<cv::Vec3f>(i, j)[2] - MIN_DEPTH) / (MAX_DEPTH - MIN_DEPTH) * 255;
				mtxDepthVis.at<cv::Vec3b>(i, j) = cv::Vec3b(fGray, fGray, fGray);
			}
			unsigned char R, G, B;
			GetDistinctColor(pLabels[i][j], R, G, B);
			mtxLabelColor.at<cv::Vec3b>(i, j) = cv::Vec3b(B, G, R);
		}
	}
	cv::imshow("Real label", mtxLabelColor);
	cv::imshow("Depth", mtxDepthVis);
}

enum OpType {TRAINING, TESTING};
int main(int argc, char *argv[]) 
{
	// indicate whether to train or test the system
	// To TRAIN the system, you need the "SampleGenerator" to prepare the training data
	OpType otUse = TESTING;
	
	// parse the configuration file
	string confFileName = "..\\conf\\conf.txt";	
	HyperParams hp(confFileName);
	
	// generate the configuration info for the depth features
	// NOTE!!: must be consistent to the parameters in the program "SampleGenerator"
	int nAnchor = 10;
	int nFeatureDim = (2 * nAnchor + 1) * (2 * nAnchor + 1) - 1;
	cv::Size sTemp(320, 240);
	SetFeatureParam(60, 10, 10, sTemp.width / 2, sTemp.height / 2, 2.0, 0.3);

	// choose whether to use uniformly or distance-adaptively depth context sampling
	// NOTE!!: must be consistent to the choice in the program "SampleGenerator"
	GenerateFeatureIndices(g_vecFeatureIndices, nFeatureDim, nAnchor, 0.10);
//	GenerateFeatureIndicesApt(g_vecFeatureIndices, nFeatureDim, nAnchor, 0.10);
	
	char text[255];
	std::string strDataDir = "..\\..\\Dataset";
	sprintf(text, "T%d", nAnchor);
	std::string strDataName = text;

	if (otUse == TRAINING)
	{
		// load the training samples generated by the program "SampleGenerator"
		// you can load multiple sample set here by push_back files names in "vecFileNames"
		DataSet dataset_tr;
		vector<string> vecFileNames;
		sprintf(text, "%s\\DigitGestures_%d.mat", strDataDir.c_str(), nAnchor);
		vecFileNames.push_back(text);
		dataset_tr.loadMultipleDatasets(vecFileNames);	

		// begin training
		struct _timeb gsTimeStart, gsTimeEnd;
		_ftime(&gsTimeStart);

		RandomForest model(hp);
		model.train(dataset_tr);
		
		sprintf(text, "%s\\forest_%s_%d.txt", strDataDir.c_str(), strDataName.c_str(), hp.MaxDepth);
		model.saveForest(text);

		_ftime(&gsTimeEnd);
		int nTimeCost=(gsTimeEnd.time * 1000 + gsTimeEnd.millitm) - (gsTimeStart.time * 1000 + gsTimeStart.millitm);	
		cout << "Training time: " << nTimeCost << endl;
	}
	else if (otUse == TESTING)
	{
		RandomForest model;

		sprintf(text, "%s\\forest_%s_%d.txt", strDataDir.c_str(), strDataName.c_str(), hp.MaxDepth);
		model.readForest(text);

		cv::Mat mtxNewLabels = cv::Mat(sTemp, CV_8UC1);
		cv::Mat mtxTest = cv::Mat(sTemp, CV_8UC3);
		cv::Mat mtxDepthPoints = cv::Mat(sTemp, CV_32FC3);
		int** pLabels = NULL;
		int nWidth, nHeight;
		HandParams param;

		// begin testing
		int nStartFileNum = 7938;
		int nEndFileNum = 8038;
		std::string strTestName = "DigitGestures";

		int nTestFileRate = 5;
		for (int fn = nStartFileNum; fn < nEndFileNum; fn++)
		{			
			if ((fn - nStartFileNum) % nTestFileRate != 0)
				continue;

			sprintf(text, "%s\\%s", strDataDir.c_str(), strTestName.c_str());
			ReadOneFrame(text, fn, mtxDepthPoints, pLabels, nWidth, nHeight, param);

			// perform classification
			model.test(mtxDepthPoints, mtxNewLabels);
			
			// show the predicted hand parts
			for (int i = 0; i < mtxNewLabels.rows; i++)
			{
				for (int j = 0; j < mtxNewLabels.cols; j++)
				{
					int nPredLabel = mtxNewLabels.at<unsigned char>(i, j);

					unsigned char R, G, B;
					GetDistinctColor(nPredLabel, R, G, B);
					mtxTest.at<cv::Vec3b>(i, j) = cv::Vec3b(B, G, R);
				}
			}
			cv::imshow("PredLabel", mtxTest);
			cv::waitKey(5);
		}
	}
	return EXIT_SUCCESS;
}
